use crate::ast::*;
use crate::lexer::Token;
use std::ops::Range;

grammar<'input>(input: &'input str);

pub Program: Program = Declaration* => Program { declarations: <> };

Declaration: Declaration = {
    ControlDecl => Declaration::Control(<>),
    ConstantDecl => Declaration::Constant(<>),
    Instantiation => Declaration::Instantiation(<>),
};

ControlDecl: ControlDecl =
    "control" <name:Identifier> "(" <params:Comma<Param>> ")"
        "{" <local_decls:ControlLocalDecl*> "apply" <apply_body:BlockStatement> "}"
    => ControlDecl { name, params, local_decls, apply_body };

ControlLocalDecl: ControlLocalDecl = {
    VariableDecl => ControlLocalDecl::Variable(<>),
    Instantiation => ControlLocalDecl::Instantiation(<>),
    ConstantDecl => ControlLocalDecl::Constant(<>),
    ActionDecl => ControlLocalDecl::Action(<>)
};

ActionDecl: ActionDecl = "action" <name:Identifier> "(" <params:Comma<Param>> ")" <body:BlockStatement>
    => ActionDecl { name, params, body };

Param: Param = <direction:Direction> <ty:TypeRef> <name:Identifier>
    => Param { direction, ty, name };

Argument: Argument = {
    Expr => Argument::Value(<>),
    <name:Identifier> "=" <value:Expr> => Argument::Named(name, value),
    "_" => Argument::DontCare
};

Statement: Statement = {
    BlockStatement => Statement::Block(<>),
    IfStatement => Statement::If(<>),
    Assignment => Statement::Assignment(<>),
// FIXME: Uncommenting this statement causes a parsing ambiguity. The fix seems
//        to be writing a custom lexer, according to
//        https://p4.org/p4-spec/docs/P4-16-v1.2.1.html#sec-grammar
//    FunctionCall => Statement::FunctionCall(<>)
};

StatementOrDecl: StatementOrDecl = {
    Statement => StatementOrDecl::Statement(<>),
    VariableDecl => StatementOrDecl::VariableDecl(<>),
    ConstantDecl => StatementOrDecl::ConstantDecl(<>),
    Instantiation => StatementOrDecl::Instantiation(<>)
};

BlockStatement: BlockStatement = "{" <StatementOrDecl*> "}" => BlockStatement(<>);

Instantiation: Instantiation = <ty:TypeRef> "(" <args:Comma<Argument>> ")" <name:Identifier> ";"
    => Instantiation { ty, args, name };

VariableDecl: VariableDecl = {
    <ty:TypeRef> <name:Identifier> <value:("=" <Expr>)?> ";" => VariableDecl { ty, name, value },
};

ConstantDecl: ConstantDecl = "const" <ty:TypeRef> <name:Identifier> "=" <value:Expr> ";"
    => ConstantDecl { ty, name, value };

Assignment: Assignment = <name:Identifier> "=" <value:Expr> ";"
    => Assignment { name, value };

FunctionCall: FunctionCall = <name:Identifier> "(" <arguments:Comma<Argument>> ")" ";"
    => FunctionCall { name, arguments };

IfStatement: IfStatement = {
    // To avoid ambiguity, only allow block statements in then/else
    "if" "(" <condition:Expr> ")" <then_case:BlockStatement> <else_case:("else" <BlockStatement>)?>
        => IfStatement { condition, then_case, else_case }
};

Expr: Expr = {
    #[precedence(level = "1")]
    Bool => Expr::Bool(<>),
    #[precedence(level = "1")]
    Identifier => Expr::Var(<>),
    #[precedence(level = "1")]
    "(" <Expr> ")",
    #[precedence(level = "1")]
    "!" <Expr> => Expr::Negation(Box::new(<>)),
    #[precedence(level = "1")]
    <name:Identifier> "(" <arguments:Comma<Argument>> ")"
        => Expr::FunctionCall(FunctionCall { name, arguments }),

    #[precedence(level = "2")]
    #[assoc(side = "left")]
    <left:Expr> "&&" <right:Expr> => Expr::And(Box::new(left), Box::new(right)),

    #[precedence(level = "3")]
    #[assoc(side = "left")]
    <left:Expr> "||" <right:Expr> => Expr::Or(Box::new(left), Box::new(right)),
};

Bool: bool = {
    "true" => true,
    "false" => false
};

Direction: Direction = {
    "in" => Direction::In,
    "out" => Direction::Out,
    "inout" => Direction::InOut
};

// Treat types as identifiers for simplicity
TypeRef = Identifier;

Identifier: String = "IDENT" => <>.to_string();

// File path, must contain a period
Path: String = "FILE_PATH" => <>.to_string();

// Allows trailing element
Comma<T>: Vec<T> = {
   <mut v:(<T> ",")*> <e:T?> => {
       v.extend(e);
       v
   }
};

extern {
    type Location = usize;
    type Error = Range<usize>;

    enum Token<'input> {
        "=" => Token::Equals,
        "_" => Token::Underscore,
        ";" => Token::Semicolon,
        "," => Token::Comma,
        "!" => Token::Exclamation,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "&&" => Token::AndAnd,
        "||" => Token::OrOr,
        "control" => Token::Control,
        "apply" => Token::Apply,
        "action" => Token::Action,
        "const" => Token::Const,
        "if" => Token::If,
        "else" => Token::Else,
        "in" => Token::In,
        "out" => Token::Out,
        "inout" => Token::InOut,
        "true" => Token::True,
        "false" => Token::False,
        "IDENT" => Token::Identifier(<&'input str>),
        "FILE_PATH" => Token::FilePath(<&'input str>),
    }
}

use crate::ast::*;

grammar;

pub Program: Program = Declaration* => Program { declarations: <> };

Declaration: Declaration = {
    ControlDecl => Declaration::Control(<>)
};

ControlDecl: ControlDecl = "control" <name:Identifier> "(" <params:Comma<Param>> ")" "{" <body:Semi<Statement>> "}"
    => ControlDecl { name, params, body };

Param: Param = <direction:ParamDirection> <ty:TypeRef> <name:Identifier>
    => Param { direction, ty, name };

Statement: Statement = {
    Assignment => Statement::Assignment(<>)
};

Assignment: Assignment = <ty:TypeRef> <name:Identifier> "=" <value:Expr> => Assignment { ty, name, value };

Expr: Expr = {
    Bool => Expr::Bool(<>),
};

Bool: bool = {
    "true" => true,
    "false" => false
};

ParamDirection: ParamDirection = {
    "in" => ParamDirection::In,
    "out" => ParamDirection::Out,
    "inout" => ParamDirection::InOut
};

// Treat types as identifiers for simplicity
TypeRef = Identifier;

Identifier: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string();

// File path, must contain a period
Path: String = r"[a-zA-Z0-9_.]+\.[a-zA-Z0-9_]+" => <>.to_string();

Deliminate<T, S>: Vec<T> = {
    <mut v:(<T> S)*> <e:T?> => {
        v.extend(e);
        v
    }
};

Comma<T> = Deliminate<T, ",">;
Semi<T> = Deliminate<T, ";">;